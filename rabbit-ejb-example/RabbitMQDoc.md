**مفاهیم پایه‌ای در RabbitMQ**

در فرآیند مسیج برُکینگ با RabbitMQ، چند مفهوم کلیدی وجود دارد که برای درک بهتر این سیستم باید آن‌ها را به‌خوبی بشناسیم. در ادامه این مفاهیم را به زبان ساده و همراه با نقش هرکدام در این فرآیند توضیح می‌دهیم:

---

### 🟦 Producer (تولیدکننده)
تولیدکننده موجودیتی است که پیام‌ها را ایجاد می‌کند و آن‌ها را برای تحویل به سیستم RabbitMQ می‌فرستد. تولیدکننده فقط مسئول ارسال پیام است و کاری به نحوه دریافت یا پردازش آن ندارد.

🔹 مثال واقعی: یک سیستم ثبت‌نام آنلاین که پس از ثبت‌نام کاربر، یک پیام به سیستم ارسال ایمیل (consumer) ارسال می‌کند.

---

### 🟨 Message (پیام)
پیام، داده‌ای است که توسط producer ارسال می‌شود. این داده می‌تواند متن ساده، JSON، فایل یا هر داده‌ای باشد که برای مصرف‌کننده (consumer) معنا دارد.

🔹 مثال: یک پیام JSON شامل اطلاعات کاربر:
```json
{
  "name": "Ali",
  "email": "ali@example.com"
}
```

---

### 🟧 Exchange (مبادله‌گر)
Exchange وظیفه دارد پیام‌هایی را که از producer دریافت می‌کند، به صف‌های مناسب هدایت کند. این کار با بررسی routing key انجام می‌شود. انواع مختلفی از Exchange داریم:
- **Direct**: بر اساس تطابق دقیق routing key
- **Topic**: بر اساس pattern‌های routing key
- **Fanout**: ارسال پیام به همه صف‌ها (broadcast)
- **Headers**: بر اساس مقادیر header پیام‌ها

🔹 مثال: یک exchange از نوع Topic می‌تواند پیام‌هایی که routing key آن‌ها `order.created` یا `order.cancelled` است به صف‌های مختلف بفرستد.

📌 **آیا می‌توان بیش از یک exchange داشت؟**
بله، در RabbitMQ شما می‌توانید چندین exchange مختلف برای اهداف و الگوهای مسیریابی مختلف داشته باشید. این exchangeها می‌توانند مستقل از هم باشند یا حتی به یک صف مشترک متصل باشند. معمولاً هر ماژول یا بخش از سیستم ممکن است exchange مخصوص به خودش را داشته باشد.

📌 **آیا می‌توان بدون exchange کار کرد؟**
خیر. در RabbitMQ تمام پیام‌ها باید به یک exchange ارسال شوند. حتی اگر شما مستقیماً به یک queue پیام بفرستید، در واقع دارید از exchange پیش‌فرض RabbitMQ به نام "(default exchange)" استفاده می‌کنید که یک direct exchange داخلی است و نام ندارد (`""`). این exchange به صورت خودکار پیام را به صفی که نامش دقیقاً برابر با routing key است هدایت می‌کند.

📸 **ساخت Exchange در RabbitMQ Management Panel**

برای ساخت Exchange در رابط مدیریتی RabbitMQ:
1. وارد آدرس [http://localhost:15672](http://localhost:15672) شوید.
2. با نام کاربری و رمز عبور خود لاگین کنید (پیش‌فرض guest/guest).
3. روی تب "Exchanges" کلیک کنید.
4. در قسمت "Add a new exchange":
    - نام exchange را وارد کنید.
    - نوع آن را انتخاب کنید (Direct, Topic, Fanout, Headers).
    - گزینه‌هایی مانند durable و auto-delete را مشخص کنید.
5. روی دکمه "Add exchange" کلیک کنید.

![پنل ساخت Exchange در RabbitMQ](https://i.imgur.com/RPmtUQB.png)

---

### 🟫 Queue (صف)
صف مکانی است که پیام‌ها را تا زمانی که مصرف‌کننده آن‌ها را دریافت کند، نگه می‌دارد. پیام‌ها در صف‌ها به صورت First-In-First-Out (FIFO) پردازش می‌شوند.

🔹 مثال: صفی به نام `emailQueue` که تمام پیام‌های مربوط به ارسال ایمیل در آن قرار می‌گیرند.

📌 **آیا می‌توان بیش از یک consumer برای یک queue داشت؟**
بله، شما می‌توانید چندین consumer به یک صف متصل کنید. در این حالت، هر پیام فقط توسط یکی از مصرف‌کنندگان پردازش می‌شود (load balancing). RabbitMQ به صورت Round-Robin پیام‌ها را بین مصرف‌کنندگان توزیع می‌کند.

🔸 **مثال کاربردی:**
فرض کنید یک صف `pdfGenerationQueue` دارید و ۳ consumer به آن متصل کرده‌اید تا فایل PDF تولید کنند. اگر ۹ پیام در صف قرار بگیرد، هر consumer به صورت تقریبی ۳ پیام دریافت خواهد کرد. این کار باعث افزایش سرعت پردازش و توزیع بار کاری می‌شود.

🖼️ **تصویر مفهومی:**
```text
Queue: pdfGenerationQueue
   |
   |---> Consumer 1
   |---> Consumer 2
   |---> Consumer 3
```

در این مدل، اگر یک consumer کندتر باشد، ممکن است پیام‌ها نامتعادل توزیع شوند، مگر اینکه قابلیت‌هایی مثل **Consumer Acknowledgement** و **Prefetch Count** به‌درستی پیکربندی شوند.


---

### 🟥 Routing Key (کلید مسیر)
رشته‌ای است که توسط producer مشخص می‌شود و exchange از آن برای تصمیم‌گیری در مورد این‌که پیام باید به کدام صف برود، استفاده می‌کند.

🔹 مثال: کلید `user.registered` می‌تواند توسط یک exchange از نوع Topic برای ارسال پیام به صف‌های مرتبط با ثبت‌نام استفاده شود.

---

### 🟩 Consumer (مصرف‌کننده)
مصرف‌کننده اپلیکیشنی است که پیام‌ها را از صف دریافت می‌کند و آن‌ها را پردازش می‌کند. مصرف‌کننده می‌تواند به صورت **pull-based** یا **push-based** پیام‌ها را دریافت کند.

🔹 مثال: سرویسی که پیام‌های صف `emailQueue` را دریافت و ایمیل خوش‌آمدگویی برای کاربران جدید ارسال می‌کند.

---

### 🧩 دیاگرام مفهومی ساده از جریان پیام:

```text
Producer
   |
   v
Exchange <-- Routing Key
   |
   v
 Queue
   |
   v
Consumer
```

در این دیاگرام:
- Producer پیام را به Exchange می‌فرستد.
- Exchange بر اساس Routing Key تصمیم می‌گیرد که پیام به کدام Queue برود.
- Consumer پیام را از Queue می‌خواند و پردازش می‌کند.

---

📘 فصل دوم: بررسی بخش‌های مختلف RabbitMQ Management Panel

در این فصل به بررسی دقیق صفحات مختلف پنل مدیریتی RabbitMQ می‌پردازیم. هر بخش از این پنل اطلاعات مهمی راجع‌به عملکرد سیستم و منابع موجود فراهم می‌کند.

🟦 Overview (نمای کلی)
---------------
در این صفحه اطلاعات کلی از وضعیت سیستم RabbitMQ نمایش داده می‌شود. از جمله:

📊 نمودارهای مهم:

Queued Messages

این نمودار نشان می‌دهد که چه تعداد پیام در صف‌ها وجود دارند و هنوز توسط Consumer مصرف نشده‌اند.

پارامترهای کنار آن:

Ready: تعداد پیام‌هایی که آماده مصرف توسط Consumer هستند.

Unacked (Unacknowledged): تعداد پیام‌هایی که توسط یک Consumer دریافت شده‌اند ولی هنوز تأیید (ack) نشده‌اند.

Total: مجموع Ready و Unacked

Message Rates

این نمودار نرخ ارسال و دریافت پیام‌ها را نشان می‌دهد.

پارامترهای کنار آن:

Publish: نرخ پیام‌هایی که توسط Producer به سیستم ارسال می‌شود.

Deliver (no-ack): نرخ پیام‌هایی که بدون نیاز به ack به Consumer ارسال شده‌اند.

Deliver (manual ack): پیام‌هایی که باید توسط Consumer تأیید شوند.

Acknowledge: نرخ ack شدن پیام‌ها توسط مصرف‌کننده‌ها

Get: نرخ pull کردن پیام‌ها توسط Consumerها (زمانی که pull-based هست)

📦 اطلاعات دیگر:

Nodes: تعداد نودهای فعال در سیستم.

Connections: تعداد اتصال‌های باز از کلاینت‌ها.

Channels: تعداد کانال‌های باز شده توسط connectionها.

Consumers: تعداد مصرف‌کننده‌های فعال در حال حاضر.

Exchanges / Queues / Bindings: تعداد کلی منابع موجود در سیستم.

🔹 این بخش نمای کلی و لحظه‌ای از سلامت و ترافیک RabbitMQ را نشان می‌دهد و برای مانیتورینگ زنده بسیار مفید است.

--------------
--------------
--------------

🔁 Exchanges (مبادله‌گرها) 
---------------
در این بخش می‌توانیم Exchangeهای موجود را ببینیم، ایجاد کنیم یا حذف کنیم.

🔹 Exchange چیست؟

Exchangeها پیام‌ها را از producer دریافت کرده و آن‌ها را بر اساس routing key به queue مناسب هدایت می‌کنند. آن‌ها هسته اصلی منطق توزیع پیام هستند.

🔹 Add a New Exchange

در تب ایجاد Exchange جدید باید فیلدهای زیر را پر کنیم:

Name: نام Exchange

Type:

direct: تطابق دقیق routing key

topic: تطابق با الگوهای routing key

fanout: ارسال به همه صف‌های bind شده

headers: تصمیم‌گیری بر اساس header پیام

Durability:

اگر فعال باشد، Exchange در ری‌استارت RabbitMQ باقی می‌ماند.

Auto Delete:

اگر فعال باشد، Exchange زمانی که هیچ صفی به آن متصل نباشد حذف می‌شود.

Internal:

اگر فعال باشد، Exchange فقط توسط خود سرور استفاده می‌شود، نه از سمت producer.

Arguments:

پارامترهای اضافی مانند تنظیمات TTL، محدودیت حجم یا تعداد پیام، و غیره.

🔹 جدول پایین صفحه

لیستی از Exchangeهای موجود را نمایش می‌دهد با اطلاعاتی مثل:

نام

نوع

durable بودن

تعداد bindings و صف‌هایی که به آن وصل شده‌اند

از این جدول می‌توان برای حذف، ویرایش یا بررسی دقیق‌تر Exchangeها استفاده کرد.

-------------------

🔁 Queues and Streams 
---------------
🔹 Virtual Host (میزبان مجازی)

در RabbitMQ، Virtual Host یا به اختصار vhost مثل یک فضای مجزای منطقی عمل می‌کند که منابع مانند صف‌ها، exchangeها، bindingها و مجوزهای کاربران را از هم جدا نگه می‌دارد.

🔸 مثال: اگر شما چند برنامه‌ی مختلف دارید که از RabbitMQ استفاده می‌کنند، می‌توانید برای هرکدام یک vhost تعریف کنید تا منابعشان با یکدیگر تداخل نداشته باشند.

📌 هر vhost یک محیط ایزوله ایجاد می‌کند که باعث افزایش امنیت و سازمان‌دهی بهتر می‌شود.

---------------
## 🔹 Type (نوع)

در این بخش باید مشخص کنید که قصد ساخت چه نوع موجودیتی را دارید:

Queue: صف معمولی که پیام‌ها را به صورت FIFO ذخیره می‌کند.

Stream: ساختاری جدیدتر برای نگهداری و پردازش حجم بالای داده‌ها با پشتیبانی از replay و offset-based consumption (مناسب برای تحلیل داده‌ها و سیستم‌های مشابه Kafka).

🔸 تفاوت اصلی:

Queue: مناسب برای مسیریابی ساده و مصرف پیام بلافاصله.

Stream: مناسب برای نیاز به تحلیل پیام‌ها یا دریافت چندباره پیام‌ها توسط چند Consumer.

---------------
## 🔹 Name (نام)

در این فیلد باید یک نام یکتا برای صف یا استریم خود وارد کنید. این نام در vhost مورد نظر باید یکتا باشد.

🔹 پیشنهاد: از نام‌هایی استفاده کنید که هدف صف را مشخص کنند، مثلاً:

emailQueue

orderStream

paymentQueue

---------------
 🟫 Durability (پایداری)
---------------
✅ اگر Durable رو فعال کنید، صف یا استریم شما بعد از ری‌استارت شدن RabbitMQ باقی می‌مونه.

🔹 اگر این گزینه غیرفعال باشه، صف بعد از ری‌استارت RabbitMQ حذف می‌شه.

📌 توجه: فقط durable بودن صف کافی نیست. اگر می‌خواید پیام‌ها هم باقی بمونن، باید پیام‌ها رو به‌صورت persistent ارسال کنید. یعنی هم صف باید durable باشه و هم پیام.


---------------
 🟫 Arguments (پارامترهای اضافی)
---------------

در این بخش می‌تونید ویژگی‌های پیشرفته‌ای رو برای صف یا استریم تعیین کنید. چند مورد از پرکاربردترین آرگومان‌ها:

---------------
🟢 x-message-ttl (زمان زنده بودن پیام)

با این آرگومان مشخص می‌کنید که یک پیام حداکثر چه مدت در صف باقی بمونه.

مقدار برحسب میلی‌ثانیه

اگر این زمان بگذره و پیام مصرف نشه، به‌طور خودکار حذف می‌شه.

---------------
🔸 مثال:

"x-message-ttl": 60000

پیام فقط 60 ثانیه در صف باقی می‌مونه.

---------------
🔴 x-dead-letter-exchange (اکسچنج پیام‌های مرده)

اگر پیام به دلیل TTL یا رد شدن توسط consumer قابل تحویل نباشه، به اصطلاح Dead Letter می‌شه. با این آرگومان می‌تونید تعیین کنید این پیام‌ها به کدوم Exchange جدید هدایت بشن.

🔸 کاربرد مهم: ساخت صف‌های failover یا برای بررسی خطاها

---------------

🟡 x-max-length (حداکثر طول صف)
تعیین می‌کنه که چند پیام می‌تونن در صف قرار بگیرن. اگر از این مق
دار عبور کنیم، پیام‌های قدیمی حذف می‌شن.

---------------

🔸 مثال:


"x-max-length": 1000
فقط 1000 پیام می‌تونن در صف بمونن.

---------------

🔵 x-max-length-bytes (حداکثر حجم صف به بایت)

مشابه قبلی، ولی محدودیت بر اساس حجم پیام‌ها به جای تعداد اون‌ها.

---------------

🟣 x-queue-mode

این پارامتر مشخص می‌کنه صف شما در چه حالتی باشه:

default: حالت عادی

lazy: پیام‌ها به جای حافظه، روی دیسک ذخیره می‌شن تا مصرف رم کم‌تر بشه (مناسب برای صف‌های سنگین)

-------

🟠 x-expires (Auto Expire)

این آرگومان مشخص می‌کنه اگر هیچ ارتباطی (no consumer, no producer) با این صف برای مدتی برقرار نشه، صف به‌صورت خودکار حذف بشه.

📌 مقدار برحسب میلی‌ثانیه

🔸 مثال:

"x-expires": 300000
اگر صف به مدت ۵ دقیقه بدون استفاده بمونه، حذف می‌شه.

🔹 کاربرد: مناسب برای صف‌هایی که حالت موقتی دارن و نمی‌خواید همیشه در سیستم باقی بمونن.

-------

🟡 x-message-ttl (Message TTL)

 این آرگومان مشخص می‌کنه که هر پیام چقدر زمان برای موندن در صف داره. بعد از اون حذف می‌شه یا به صف Dead Letter فرستاده می‌شه (اگه تنظیم شده باشه).

🔸 مثال:

"x-message-ttl": 120000
هر پیام فقط ۲ دقیقه در صف می‌مونه.

-------

🔴 overflow (Overflow Behaviour)

مشخص می‌کنه وقتی صف به حداکثر ظرفیت خودش (با x-max-length یا x-max-length-bytes) رسید، چه اتفاقی بیفته:

drop-head: پیام‌های قدیمی‌تر حذف بشن تا جا برای پیام جدید باز بشه.

reject-publish: پیام جدید رد بشه (نپذیرفته بشه).

🔸 مثال:

"x-overflow": "drop-head"
اگر صف پر باشه، پیام‌های قدیمی رو حذف می‌کنه تا جدیدها وارد بشن.

-------

🟢 x-single-active-consumer (Only One Active Consumer)

اگر این مقدار true باشه، حتی اگر چند Consumer به صف متصل باشن، فقط یکی از آن‌ها فعال می‌مونه. بقیه در حالت standby می‌مونن تا زمانی که active fail بشه.

🔸 مثال:

"x-single-active-consumer": true

🔹 کاربرد: زمانی که نمی‌خواید پردازش موازی داشته باشید و فقط یک consumer خاص پیام‌ها رو بخونه.

-------------

🟣 x-dead-letter-routing-key (Dead Letter Routing Key)

این کلید جایگزین Routing Key اصلی می‌شه وقتی که پیام از این صف به سمت Dead Letter Exchange می‌ره.

🔸 مثال:

"x-dead-letter-exchange": "deadExchange",

"x-dead-letter-routing-key": "dead.task.timeout"

🔹 کاربرد: مسیریابی دقیق‌تر پیام‌های ناموفق به صف خاص (مثلاً صف خطا یا صف retry).

-----------

🔵 x-leader-locator (فقط برای Stream)

این آرگومان برای صف‌هایی از نوع Stream استفاده می‌شه و مشخص می‌کنه وقتی Stream به صورت توزیع‌شده (replicated) باشه، leader node چطور انتخاب بشه.

گزینه‌ها:

balanced: انتخاب leader به صورت تعادلی بین نودها

client-local: تلاش برای انتخاب nodی که client بهش وصله

random: انتخاب تصادفی

🔸 مثال:

"x-leader-locator": "client-local"

🔹 کاربرد: در سیستم‌های توزیع‌شده برای بهینه‌سازی latency و تعادل بار بین نودها